## 基础定义

    int *p; // 定义p只能储存int类型的变量地址，p是指针变量，里面的内容是指针，就是地址
    int i = 3;
    p = &i; // 代表了 p指向了i的地址， p 保存了i的地址
    j = *p; //代表了j = i， *p代表了i的值，就是以p的内容为地址的变量
    
## 重要性
可以用来表达一下复杂的数据结构：链表，树
快速的传递数据，使函数返回一个以上的值，能够直接访问硬件，方便处理字符串

## 什么是地址
地址就是内存单元的编号，从0开始的非负整数， 在32位系统的范围是0 - (4G-1)

指针就是地址，本质就是一个操作受限的非负整数

## 分类
基本类型指针， 和数组， 和函数，和结构体，还有多级指针的关系
基本类型的指针就是之前的基础定义

## 常见错误
*p 是以p的内容为地址的变量， 因此不能直接定义 *p = i，需要先处理p = &i

## *的含义
第一个用法是乘法，第二个定义指针变量，第二个是对地址取值，以p的内容为地址的变量

        void swap(int *a, int *b){
            int t;
            t = *a;
            *a = *b;
            *b = t;
        }
        int main(void){
            int a = 3;
            int b= 4;
            swap(&a, &b); // 通过地址指针可以调换两个值
        }
        
## 通过被调函数来修改全局变量的值
需要实参为普通变量的地址，形参需要时指针变量， *形参名= ...

## 指针和数组
1.指针和一位数组
一位数组名是一个指针常量，存放的是一位数组第一个元素的地址， 因此 
int a[5]; 这时候 a = &a[0] 这两个的值是一样的

2. 下标和指针的关系， 如果p是个指针变量，p[i] = *(p+i)

3.确定一个数组需要2个参数

        void f(int * pArr, int len)
## 指针的运算

        int * p = &i;
        int * q = &j;
        如果想减可以获得相隔的距离
        
## 指针变量占多少字节
用sizeof可以知道所占字节数

int 的地址：
char 的地址
double 的地址 
本身的大小都是占4个字节，无论地址指向的变量是什么类型
通过数据类型可以知道*指针的长度

一个指针变量，无论他指向的变量占几个字节，该指针本身只占4个字节

## 动态内存分配
传统数组的缺点：
1. 数组长度必须事先指定，且只能是常整数，不能是变量 eg 不能 int a[len]; 这长度不能是变量
2. 传统形式定义的数组，该数组的内存无法手动释放 eg int a[5]; 这20个字节不能在程序中自己释放，只能在函数结束的时候才能由系统自动释放，数组一旦定义，系统会为该数组的分配空间就会一直存在直到该函数终止
3。 数组的长度不能改变在函数运行的过程中，动态的扩充或者缩小
4. 函数a中定义的数组可以被其他函数使用，但是a函数终止后，就不能使用、

为什么要动态内存分配：
可以解决传统数组的缺陷，就是静态数组的缺陷

使用方法：需要用到malloc 函数，只有一个形参，是整型

        int *p = (int *)malloc(4); //  请求系统分配4个字节，返回第一个字节的地址，因此需要在前面强制类型转换来分配变量所占的字节数量
        这个分配了8个字节，p变量占了4个字节， p本身是静态的，但是指向的是动态分配的
        free(p); // 可以把p所指向的内存释放掉
        
## 如何动态分配一维数组

        int len;
        int *pArr;
        printf("enter the length of array\n");
        scanf("%d", &len);
        pArr = (int *) malloc(4 * len);
        pArr[0] = 7; //pArr[0]是等于 *pArr
        *(pArr + 1) = 3;
        printf("%d , %d\n",pArr[0],pArr[1]);
        //如果要手动输入赋值
        int i;
        for (i = 0; i < len; i++)
            scanf("%d",&pArr[i]);
        for (i = 0; i < len; i++)
            printf("%d\n",pArr[i]);
        
        free(pArr); //可以手动的动态释放
        return 0;
realloc(变量，新的大小) - 可以手动的修改大小

##  动态内存
是在堆中分配的，是由程序员手动分配

## 多级指针

        int i = 10;
        int *p = &i;
        int ** q= &p;
        int *** r= &q;
        
例子：

        void f(int **q);
        {
            *q
        }
        void g(){
            int i = 10;
            int * p = &i;
            f(&p);
        }
        
用于跨函数使用内存

## 跨函数使用内存

有问题的静态变量跨函数使用

    void f(int **p){ 
        int i =5;
        // *q 等价于p， q和**q都不是p
        *q = &i;
        
    }
    int main(void) {
        int * p;
        f(&p);
        printf("%d/n",*p); // 这里的i被释放了，所以逻辑上不能使用
    }
        
跨函数使用动态内存

